package projecteuler;

public class prob2 {
	// naive recursive implementation
	public static long fib(int n) {
        if (n <= 1) return n;
        else return fib(n-1) + fib(n-2);
    }
	
	/* Each new term in the Fibonacci sequence is generated by adding 
	 * the previous two terms. By starting with 1 and 2, the first 10 
	 * terms will be:

		1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

	 * By considering the terms in the Fibonacci sequence whose values 
	 * do not exceed four million, find the sum of the even-valued 
	 * terms.
	 */

	public static void main(String[] args) {
		long curr_fib = 0L;
		long even_sum = 0L;
		int  n =2;
		
		while(curr_fib <= 4000000) {
			if ( (curr_fib = fib(n)) % 2 == 0)
				even_sum += curr_fib;
			n++;
		}
		System.out.println("Sum: "+even_sum);
	}
}
	// method f1b.fib(n,m) first checks if the result for 'n' has already
	 // been calculated. If so, the result is returned. Otherwise,
	 // binary recursion F(n) = F(n-1) + F(n-2) is performed, its result
	 // saved and returned.
//	private static HashMap<BigInteger, BigInteger> cache = new HashMap<BigInteger, BigInteger>();
//    
//	 private static BigInteger fib(int n, HashMap<Integer, BigInteger> m) {
//	    if(m.containsKey(n)) return m.get(n);
//	    BigInteger result = n<=0 ? BigInteger.ZERO
//	                      : n==1 ? BigInteger.ONE
//	                      : fib(n-2, m).add(fib(n-1, m));
//	    m.put(n, result);
//	    return result;
//	 }
//	 private static BigInteger fibs(int n) {
//	     HashMap<Integer, BigInteger> memo = new HashMap<Integer, BigInteger>(n); 
//	     return fib(n, memo);
//	 }
//	public static int fibonacci2(int number){
//        if(number == 1 || number == 2){
//            return 1;
//        }
//        int fibo1=1, fibo2=1, fibonacci=1;
//        for(int i= 3; i<= number; i++){
//            fibonacci = fibo1 + fibo2; //Fibonacci number is sum of previous two Fibonacci number
//            fibo1 = fibo2;
//            fibo2 = fibonacci;
//          
//        }
//        return fibonacci; //Fibonacci number
//      
//    }
//	
//	/* http://blog.informatech.cr/2013/05/08/memoized-fibonacci-numbers-with-java-8/#comment-2370
//	
//	private static Map<Integer,BigInteger> memo = new HashMap<Integer,BigInteger>();
//	static {
//	   memo.put(0,BigInteger.valueOf(0L)); //fibonacci(0)
//	   memo.put(1,BigInteger.valueOf(1L)); //fibonacci(1)
//	}
//	
//	public static long fibonacci(int x) {
//		   return memo.computeIfAbsent(x, n -> fibonacci(n-1) + fibonacci(n-2));
//	} */
//	
	
//	private static BigInteger ZERO = new BigInteger(Integer.toString(0));
//	private static BigInteger ONE  = new BigInteger(Integer.toString(1));
//	
//	
//	public static BigInteger fibonacci(BigInteger n) {
//        if (n.equals(ZERO)) return ZERO;
//        if (n.equals(ONE))  return ONE;
//        if (cache.containsKey(n)) return cache.get(n);
//
//        // odd
//        if (n.testBit(0)) {
//            BigInteger n2 = n.shiftRight(1);
//            BigInteger n3 = n2.add(ONE);
//            BigInteger result = fibonacci(n2).multiply(fibonacci(n2)).add(fibonacci(n3).multiply(fibonacci(n3)));
//            cache.put(n, result);
//            return result;
//        }
//
//        // even
//        else {
//            BigInteger n2 = n.shiftRight(1);
//            BigInteger n3 = n2.subtract(ONE);
//            BigInteger result = fibonacci(n2).multiply(fibonacci(n2).add(fibonacci(n3).add(fibonacci(n3))));
//            cache.put(n, result);
//            return result;
//        }
//    }

	// naive recursive implementation
//	public static long fib(int n) {
//        if (n <= 1) return n;
//        else return fib(n-1) + fib(n-2);
//    }

//	private static HashMap<BigInteger, BigInteger> cache = new HashMap<BigInteger, BigInteger>();
//    private static BigInteger TWO  = new BigInteger("2");
//    private static BigInteger ONE  = BigInteger.ONE;
//    private static BigInteger ZERO = BigInteger.ZERO;
//
//    public static BigInteger fibonacci(BigInteger n) {
//        if (n.equals(ZERO)) return ZERO;
//        if (n.equals(ONE))  return ONE;
//        if (cache.containsKey(n)) return cache.get(n);
//
//        // odd
//        if (n.testBit(0)) {
//            BigInteger n2 = n.shiftRight(1);
//            BigInteger n3 = n2.add(ONE);
//            BigInteger result = fibonacci(n2).multiply(fibonacci(n2)).add(fibonacci(n3).multiply(fibonacci(n3)));
//            cache.put(n, result);
//            return result;
//        }
//
//        // even
//        else {
//            BigInteger n2 = n.shiftRight(1);
//            BigInteger n3 = n2.subtract(ONE);
//            BigInteger result = fibonacci(n2).multiply(fibonacci(n2).add(fibonacci(n3).add(fibonacci(n3))));
//            cache.put(n, result);
//            return result;
//        }
//    }
//
//    public static void main(String[] args) { 
//        BigInteger N    = new BigInteger("0");
//        BigInteger summ = new BigInteger("0");
//        BigInteger curr_fib = new BigInteger("0");
//        
//        // initializing
//        BigInteger n_minus1 = BigInteger.ONE;  // n = 1
//        BigInteger n_minus2 = BigInteger.ZERO; // n = 0
//        
//        while(curr_fib.compareTo(new BigInteger("4000000"))){
//        	N = new BigInteger(Integer.toString(i));
//        	//System.out.println(curr_fib+" " +n_minus1+" "+n_minus2);
//        	curr_fib = n_minus2.add(n_minus1);
//        	//System.out.println(curr_fib+" " +n_minus1+" "+n_minus2);//System.out.println(curr_fib+" " +n_minus1+" "+n_minus2);
//        	
//        	n_minus2 = n_minus1;
//        	n_minus1 = curr_fib;
//
//        	//System.out.println(curr_fib);        		
//        	if (curr_fib.mod(TWO).toString() == "0"){
//        		 summ = summ.add(curr_fib);
//        		 System.out.println(curr_fib);        		 
//        	}
//        }
//        System.out.println("Sum total: "+summ.toString());
//    }
